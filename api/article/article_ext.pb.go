// Code generated by protoc-gen-go-gin. DO NOT EDIT.
// versions:
// - protoc-gen-go-gin v0.0.2
// - protoc            v4.24.2
// source: api/article.proto

package article

import (
	sonic "github.com/bytedance/sonic"
	gin "github.com/gin-gonic/gin"
	binding "github.com/gin-gonic/gin/binding"
	api "github.com/sunmi-OS/gocore/v2/api"
	ecode "github.com/sunmi-OS/gocore/v2/api/ecode"
	utils "github.com/sunmi-OS/gocore/v2/utils"
	http "net/http"
	strings "strings"
)

type TResponse[T any] struct {
	Code int    `json:"code"`
	Data *T     `json:"data"`
	Msg  string `json:"msg"`
}

var validateErr error = api.ErrorBind
var releaseShowDetail bool
var disableValidate bool

// set you error or use api.ErrorBind(diable:是否启用自动validate, 如果启用则返回 validateErr or 原始错误)
func SetAutoValidate(disable bool, validatErr error, releaseShowDetail bool) {
	disableValidate = disable
	validateErr = validatErr
	releaseShowDetail = releaseShowDetail
}

func checkValidate(err error) error {
	if disableValidate || err == nil {
		return nil
	}
	if utils.IsRelease() && !releaseShowDetail {
		return validateErr
	}
	return err
}

const customReturnKey = "x-md-local-customreturn"

func SetCustomReturn(ctx *api.Context) {
	c := ctx.Request.Context()
	c = utils.SetMetaData(c, customReturnKey, "true")
	ctx.Request = ctx.Request.WithContext(c)
}

func setRetJSON(ctx *api.Context, resp interface{}, err error) {
	if utils.GetMetaData(ctx.Request.Context(), customReturnKey) != "" {
		return
	}
	ctx.RetJSON(resp, err)
}

func setRetOrigin(ctx *api.Context, resp interface{}) {
	if utils.GetMetaData(ctx.Request.Context(), customReturnKey) != "" {
		return
	}

	ctx.JSON(http.StatusOK, resp)
}

func parseReq(g *gin.Context, ctx *api.Context, req interface{}) (err error) {
	reqPath := g.FullPath()
	if strings.HasPrefix(reqPath, "/v2/") {
		ctx.Request.ParseForm()
		params := ctx.Request.FormValue("params")
		err = sonic.UnmarshalString(params, req)
		if err != nil {
			errMsg := "params not exist or unmarshal failed:" + err.Error()
			return ecode.NewV2(-1, errMsg)
		}
		validator := binding.Validator
		err = validator.ValidateStruct(req)
	} else {
		err = ctx.ShouldBindJSON(req)
	}
	return
}
